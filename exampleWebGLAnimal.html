<html>
<head>
  <title>Rendering primitives</title>
  <!--<link rel="shortcut icon" type="image/png" href="../common/images/favicon.png" />-->

  <!-- libraries -->
  <!--<link rel="stylesheet" href="../common/lib/normalize.css">-->
  <!--<script type="text/javascript" src="../common/lib/dat.gui.js"></script>-->

  <!-- modules -->
  <!--<script type="text/javascript" src="../common/js/utils.js"></script>-->

  <!-- vertex shader -->

  <link rel="stylesheet" href="./lib/normalize.css">
  <script type="text/javascript" src="./lib/dat.gui.js"></script>
  <script type="text/javascript" src="./js/utils.js"></script>
  <script type="text/javascript" src="./lib/gl-matrix.js"></script>
  <script type="text/javascript" src="./objects.js"></script>
  <script type="text/javascript" src="./simpleGLStack.js"></script>
  <script type="text/javascript" src="./geometry.js"></script>
  <script type="text/javascript" src="./webGLApp.js"></script>
  <script type="text/javascript" src="./webGLModel.js"></script>
  <script type="text/javascript" src="./shapes.js"></script>
  <script type="text/javascript" src="./shapesWebGL.js"></script>
  

<!--Vertex Shader-->
   
<script id="vertex-shader" type="x-shader/x-vertex">
    #version 300 es
    precision mediump float;
    precision mediump int;

    in vec3 aVertexPosition;
    in vec3 aVertexColor;
    in vec3 aVertexNormal;
    in vec2 aTextureCoordinate;
    

    smooth out vec4 vColor;
    smooth out vec3 vNormal;
    out vec2 vTextureCoordinate;
    uniform float uVertexPointSize;
    uniform mat4 uModelViewMatrix;
    uniform mat4 uNormalMatrix;
    uniform mat4 uProjectionMatrix;
    uniform int uTextureActive;
    uniform vec3 uLightPos;
    uniform vec3 uEyePos;

    void main(void) {
      mat4 normalMatrix = inverse(uModelViewMatrix);
      normalMatrix = transpose(normalMatrix);

      vec4 pos = vec4(aVertexPosition,1.0);
      vec4 normal = normalMatrix*vec4(aVertexNormal,0.0);
      vec4 light =  uNormalMatrix*vec4(uLightPos,0.0);
      vec4 newPos = uProjectionMatrix*uModelViewMatrix * pos;
      vColor = vec4(aVertexColor,1.0); 

      vec3 normalVec = normalize(vec3(normal));
      vec3 lightVec = normalize(vec3(light));
      vec3 eyeVec = normalize(vec3(uEyePos));

      float lambert = dot(normalVec,lightVec);
      vec4 matDiff,matSpec;

      //Se houver textura, o material da superficie e definido pela cor dos vertices
      if (uTextureActive==0){
        matDiff = vColor;
        matSpec = vColor;
      }
      else{// se nao é um cor branca
        matDiff = vec4(1.0,1.0,1.0,1.0);
        matSpec = vec4(1.0,1.0,1.0,1.0);
      }

      vec3 Ia; //Iluminacao ambiental
      vec3 Id; //Iluminacao Difusa
      vec3 Is; //Iluminacao Especular
      float Ka = 0.4;
      float Kd = 0.5;
      float Ks = 0.5;
      float ns = 8.0;

      //Calculo da compoenente ambiental
      Ia = Ka*vec3(1.0,1.0,1.0);

      //Se o coeficiente de atenuacao difusa for positivo
      if (lambert>0.0){//multiplica o coeficiente pelo material
        vec3 refVec = reflect(lightVec,normalVec);
        float angSpec = max(0.0,dot(refVec,eyeVec));
        float specular = pow(angSpec,ns);
        Id = Kd*vec3(lambert*matDiff);
        Is = Ks*vec3(specular*matSpec);
      }
      else{//senao a iluminacao difusa e zero
        Id = vec3(1.0,0.0,0.0);
        Is = vec3(1.0,0.0,0.0);
      }
      
      vColor = vec4(Ia+Id+Is,1.0);

      gl_PointSize = 8.0;
      gl_Position = newPos;
      vTextureCoordinate = aTextureCoordinate;
      //vNormal = aVertexNormal;
    }
  </script>
  


  <!-- fragment shader -->
  <script id="fragment-shader" type="x-shader/x-fragment">
    #version 300 es
    precision mediump float;
    precision mediump int;
    in vec4 vColor;
    in vec3 vNormal;
    in vec2 vTextureCoordinate;
    out vec4 fragColor;
    uniform int uTextureActive;


    
    uniform sampler2D uSampler;

    void main(void) {
      if (uTextureActive==0){
        fragColor = vColor*texture(uSampler,vTextureCoordinate);
        //fragColor = vec4(1.0,0.0,0.0,1.0);
      }else{
        fragColor = vColor;
        fragColor = vec4(1.0,1.0,0.0,1.0);
      }
    }
  </script>


  <script type="text/javascript">
  
    class MyWebGLMainAPP extends WebGLMainApp{
    
        constructor(){
            super();
            this.program = null;
            this.fov = 60;
            this.rotationVector = [0.0,0.0,0.0];
            this.lightPos = [0.0,1.0,1.0];
            this.translationVector = [0.0,0.0,-20.0];
            this.stack = new SimpleGLStack();
        }

        createTransformMatrices(){
        
            this.modelViewMatrix = mat4.create();
            this.projectionMatrix = mat4.create();
            this.normalMatrix = mat4.create();

            var tv = vec3.create();

            vec3.set(tv, this.translationVector[0], this.translationVector[1], this.translationVector[2]);

            mat4.fromTranslation(this.modelViewMatrix,tv);
            mat4.rotateX(this.modelViewMatrix,this.modelViewMatrix,this.rotationVector[0] * Math.PI / 180);
            mat4.rotateY(this.modelViewMatrix,this.modelViewMatrix,this.rotationVector[1] * Math.PI / 180);
            mat4.rotateZ(this.modelViewMatrix,this.modelViewMatrix,this.rotationVector[2] * Math.PI / 180);

            
            mat4.identity(this.normalMatrix);
            mat4.invert(this.normalMatrix,this.modelViewMatrix);
            mat4.transpose(this.normalMatrix,this.normalMatrix);

            //Cria a matriz de projeção com angulo de abertura de 45 graus, near plane = 0.1 e far_plane = 1000
            mat4.identity(this.projectionMatrix);  
            mat4.perspective(this.projectionMatrix, this.fov*(Math.PI/180), this.gl.canvas.width / this.gl.canvas.height, 0.1, 1000);

        }

        

        async createModels(){
            /*Textures obtained from 
            https://www.myfreetextures.com/
            https://publicdomaintextures.com/
            */

            this.wall = new Wall(this,16,4);
            this.ground = new Ground(this,64,64);
            this.animal = new Animal(this);
            this.jar = new Jar(this);
            this.leatherBall = new WebGLSphere(this.gl,this.program,3.0,32,32,new Color(1.0,0.0,0.0,1.0),"leather05 diffuse 1k.png");
            this.leatherBallModel = this.leatherBall.getWebGLModel();
        
            /* elephant obtido e adaptado de 
            https://github.com/CGAL/cgal/blob/master/Data/data/meshes/elephant-with-holes.off
            */
            this.elephant = new WebGLMesh(this.gl,this.programMesh,new Color(1.0,0.0,0.0,0.0),"elephant.json","elephant",null,null);
            await this.elephant.fetch();
            this.elephantModel = this.elephant.getWebGLModel();

            /*Laurana50k.json obtida de 
              https://github.com/cnr-isti-vclab/meshlabjs/blob/master/mesh/Laurana50k.ply
            */
            this.statue = new WebGLMesh(this.gl,this.programMesh,new Color(1.0,0.0,0.0,0.0),"Laurana50k.json","statue",null,null);
            await this.statue.fetch();
            this.statueModel = this.statue.getWebGLModel();

            /*oaktree.json obtida e adaptada de 
            https://free3d.com/3d-model/-oak-tree-v1--463277.html
            */
            this.tree = new WebGLMesh(this.gl,this.programMesh,new Color(1.0,0.0,0.0,0.0),"oaktree.json","tree",null,null);
            await this.tree.fetch();
            this.treeModel = this.tree.getWebGLModel();
            

            const controlPoints = new PointList();
            controlPoints.push(new Point3d(-4.0,0.0,-4.0,new Color(1.0,0.0,0.0),8));
            controlPoints.push(new Point3d(-4.0,0.0,4.0,new Color(1.0,0.0,0.0),8));
            controlPoints.push(new Point3d(4.0,0.0,4.0,new Color(1.0,0.0,0.0),8));
            controlPoints.push(new Point3d(4.0,0.0,-4.0,new Color(1.0,0.0,0.0),8));
            controlPoints.push(new Point3d(0.0,0.0,-4.0,new Color(1.0,0.0,0.0),8));
            controlPoints.push(new Point3d(0.0,10.0,-4.0,new Color(1.0,0.0,0.0),8));
            const bezier = new WebGLBezier(this.gl,this.programLines,new Color(0.0,0.0,1.0),controlPoints,5,32,false,false);
            this.bezierModel = bezier.getWebGLModel();


            const controlPoints2 = new PointList();
            controlPoints2.push(new Point3d(-8.0,0.0,-8.0,new Color(1.0,0.0,0.0),8));
            controlPoints2.push(new Point3d(-8.0,0.0,8.0,new Color(1.0,0.0,0.0),8));
            controlPoints2.push(new Point3d(8.0,0.0,8.0,new Color(1.0,0.0,0.0),8));
            controlPoints2.push(new Point3d(8.0,0.0,-8.0,new Color(1.0,0.0,0.0),8));
            controlPoints2.push(new Point3d(0.0,8.0,-8.0,new Color(1.0,0.0,0.0),8));
            controlPoints2.push(new Point3d(0.0,16.0,16.0,new Color(1.0,0.0,0.0),8));
            const knots = [0,0,0,0,1,4,5,5,5,5];

            this.bspline = new WebGLBSpline(this.gl,this.programLines,new Color(1.0,1.0,0.0),controlPoints2,knots,3,32);
            this.bsplineModel = this.bspline.getWebGLModel();

            this.cyl = new WebGLCylinder(this.gl,this.programNoise,1.0,1.0,128,128,new Color(1.0,0.0,0.0,1.0),"white-fur-texture.jpg");
            this.cylModel = this.cyl.getWebGLModel();

            this.triangle = new WebGLTriangle(this.gl,this.program,
                                            new Point3d(4.0,0.0,0.0,new Color(1.0,0.0,0.0),8),
                                            new Point3d(0.0,4.0,0.0,new Color(1.0,0.0,0.0),8),
                                            new Point3d(-4.0,0.0,0.0,new Color(1.0,0.0,0.0),8),
                                            new Color(1.0,0.0,0.0)
                                          );

            this.triangleModel = this.triangle.getWebGLModel();
       

        }

        async create(){
        
            // Carrega um program       
            //this.program = this.createProgram("vertex-shader","fragment-shader");
            this.program = await this.loadProgram("vertexShader.sh","fragmentShader.sh");
            this.programMesh = await this.loadProgram("vertexShaderMesh.sh","fragmentShader.sh");
            this.programLines = await this.loadProgram("vertexShaderLines.sh","fragmentShaderLines.sh");
            this.programNoise = await this.loadProgram("vertexShaderNoise.sh","fragmentShader.sh");
            
            this.gl.useProgram(this.program);

            //Define as variáveis attribute e uniform dos shaders
            this.attribShaderVariables = {"aVertexPosition":"aVertexPosition",
                                          "aVertexColor":"aVertexColor",
                                          "aVertexNormal":"aVertexNormal",
                                          "aVertexTextureCoord":"aTextureCoordinate"};

            this.uniformShaderVariables = ["uVertexPointSize","uModelViewMatrix","uNormalMatrix","uProjectionMatrix",
                                           "uLightPos","uEyePos","uTextureActive","uSampler"];
            
            //Define as variáveis attribute e uniform dos shaders para linhas
            this.attribShaderLinesVariables = {"aVertexPosition":"aVertexPosition",
                                              "aVertexColor":"aVertexColor",
                                              "aVertexTextureCoord":"aTextureCoordinate"};

            this.uniformShaderLinesVariables = ["uVertexPointSize","uModelViewMatrix","uProjectionMatrix","uTextureActive","uSampler"];
            

            //Define as variáveis attribute e uniform dos shaders de malhas
            this.attribShaderMeshVariables = {"aVertexPosition":"aVertexPosition",
                                              "aVertexNormal":"aVertexNormal",
                                              "aVertexTextureCoord":"aTextureCoordinate"};

            this.uniformShaderMeshVariables = ["uVertexPointSize","uModelViewMatrix","uNormalMatrix","uProjectionMatrix",
                                               "uLightPos","uEyePos",
                                               "uMatAmbient",
                                               "uKa",
                                               "uMatDiffuse",
                                               "uKd",
                                               "uMatSpecular",
                                               "uKs",
                                               "uNs",
                                               "uD",
                                               "uTextureActive","uSampler"];
            


            //Obtem a localização das variáveis no shader
            this.setProgramAttribShaderVariablesLocation(this.program,this.attribShaderVariables);
            this.setProgramUniformShaderVariablesLocation(this.program,this.uniformShaderVariables);

            this.setProgramAttribShaderVariablesLocation(this.programNoise,this.attribShaderVariables);
            this.setProgramUniformShaderVariablesLocation(this.programNoise,this.uniformShaderVariables);

            this.setProgramAttribShaderVariablesLocation(this.programLines,this.attribShaderLinesVariables);
            this.setProgramUniformShaderVariablesLocation(this.programLines,this.uniformShaderLinesVariables);
            
            this.setProgramAttribShaderVariablesLocation(this.programMesh,this.attribShaderMeshVariables);
            this.setProgramUniformShaderVariablesLocation(this.programMesh,this.uniformShaderMeshVariables);
            

            this.createTransformMatrices();
            
            await this.createModels();

            var uniformShaderVariablesValues = {"uVertexPointSize":["1f",16.0],
                                                "uModelViewMatrix":["mat4",false,this.modelViewMatrix],
                                                "uNormalMatrix":["mat4",false,this.normalMatrix],
                                                "uProjectionMatrix":["mat4",false,this.projectionMatrix],
                                                "uLightPos":["3f",this.lightPos[0],this.lightPos[1],this.lightPos[2]],
                                                "uEyePos":["3f",-this.translationVector[0],-this.translationVector[1],-this.translationVector[2]],
                                                "uTextureActive":["1i",1],
                                                "uSampler":["1i",0]};

            
            var uniformShaderLinesVariablesValues = {"uVertexPointSize":["1f",16.0],
                                                "uModelViewMatrix":["mat4",false,this.modelViewMatrix],
                                                "uProjectionMatrix":["mat4",false,this.projectionMatrix],
                                                "uTextureActive":["1i",0],
                                                "uSampler":["1i",0]};

            var uniformShaderMeshVariablesValues = {"uVertexPointSize":["1f",16.0],
                                                "uModelViewMatrix":["mat4",false,this.modelViewMatrix],
                                                "uNormalMatrix":["mat4",false,this.normalMatrix],
                                                "uProjectionMatrix":["mat4",false,this.projectionMatrix],
                                                "uLightPos":["3f",this.lightPos[0],this.lightPos[1],this.lightPos[2]],
                                                "uEyePos":["3f",-this.translationVector[0],-this.translationVector[1],-this.translationVector[2]],
                                                "uMatAmbient":["4fv",[1.0,1.0,1.0,1.0]],
                                                "uKa":["3fv",[0.5,0.5,0.5]],
                                                "uMatDiffuse":["4fv",[1.0,1.0,1.0,1.0]],
                                                "uKd":["3fv",[0.5,0.5,0.5]],
                                                "uMatSpecular":["4fv",[1.0,1.0,1.0,1.0]],
                                                "uKs":["3fv",[0.5,0.5,0.5]],
                                                "uNs":["1f",0.5],
                                                "uD":["1f",1.0],
                                                "uTextureActive":["1i",1],
                                                "uSampler":["1i",0]};  

            

            this.setProgramUniformShaderVariablesValues(this.program,uniformShaderVariablesValues);
            this.setProgramUniformShaderVariablesValues(this.programNoise,uniformShaderVariablesValues);
            this.setProgramUniformShaderVariablesValues(this.programLines,uniformShaderLinesVariablesValues);
            this.setProgramUniformShaderVariablesValues(this.programMesh,uniformShaderMeshVariablesValues);

 
        }


        drawScene(modelViewMatrix){

          
            var tv = vec3.create();
            this.stack.push(mat4.clone(modelViewMatrix));
                vec3.set(tv,  -7.0, 0.0, -5.0); 
                mat4.translate(modelViewMatrix,modelViewMatrix,tv);
                this.updateModelViewMatrix(this.wall.program,modelViewMatrix,"uModelViewMatrix");
                this.wall.draw(modelViewMatrix);
            modelViewMatrix = this.stack.pop();

            var tv = vec3.create();
            this.stack.push(mat4.clone(modelViewMatrix));
                vec3.set(tv,  -7.0, 0.0, -5.0); 
                mat4.translate(modelViewMatrix,modelViewMatrix,tv);
                mat4.rotateY(modelViewMatrix,modelViewMatrix, -90.0 * Math.PI / 180);
                this.updateModelViewMatrix(this.elephant.program,modelViewMatrix,"uModelViewMatrix");
                this.updateModelViewMatrix(this.wall.program,modelViewMatrix,"uModelViewMatrix");
                this.wall.draw(modelViewMatrix);
            modelViewMatrix = this.stack.pop();

            var tv = vec3.create();
            this.stack.push(mat4.clone(modelViewMatrix));
                vec3.set(tv,  23.0, 0.0, -5.0); 
                mat4.translate(modelViewMatrix,modelViewMatrix,tv);
                mat4.rotateY(modelViewMatrix,modelViewMatrix, -90.0 * Math.PI / 180);
                this.updateModelViewMatrix(this.elephant.program,modelViewMatrix,"uModelViewMatrix");
                this.updateModelViewMatrix(this.wall.program,modelViewMatrix,"uModelViewMatrix");
                this.wall.draw(modelViewMatrix);
            modelViewMatrix = this.stack.pop();

            this.stack.push(mat4.clone(modelViewMatrix));
                vec3.set(tv,  -30.0, -2.0, -30.0); 
                mat4.translate(modelViewMatrix,modelViewMatrix,tv);
                this.updateModelViewMatrix(this.ground.program,modelViewMatrix,"uModelViewMatrix");
                this.ground.draw(modelViewMatrix);
            modelViewMatrix = this.stack.pop();            

            this.stack.push(mat4.clone(modelViewMatrix));
                vec3.set(tv,  6.0, 0.0, 0.0); 
                mat4.translate(modelViewMatrix,modelViewMatrix,tv);
                this.updateModelViewMatrix(this.jar.program,modelViewMatrix,"uModelViewMatrix");
                this.jar.draw(modelViewMatrix);
            modelViewMatrix = this.stack.pop();

            
            this.animal.draw(modelViewMatrix);


            this.stack.push(mat4.clone(modelViewMatrix));
                vec3.set(tv,  12.0, 0.0, 6.0); 
                mat4.translate(modelViewMatrix,modelViewMatrix,tv);
                this.updateModelViewMatrix(this.leatherBall.program,modelViewMatrix,"uModelViewMatrix");
                this.leatherBallModel.draw();
            modelViewMatrix = this.stack.pop();
            
          
            
            
            //this.gl.disable(this.gl.DEPTH_TEST);
            this.stack.push(mat4.clone(modelViewMatrix));
                var tv = vec3.create();
                var s = vec3.create();
                vec3.set(tv, 4.0, 1.5, 6); 
                mat4.translate(modelViewMatrix,modelViewMatrix,tv);
                vec3.set(s, 10, 10, 10); 
                mat4.scale(modelViewMatrix,modelViewMatrix,s);
                mat4.rotateX(modelViewMatrix,modelViewMatrix, -30.0 * Math.PI / 180);
                mat4.rotateY(modelViewMatrix,modelViewMatrix, -10.0 * Math.PI / 180);
                mat4.rotateZ(modelViewMatrix,modelViewMatrix, -12.0 * Math.PI / 180);
                this.updateModelViewMatrix(this.elephant.program,modelViewMatrix,"uModelViewMatrix");
                this.elephantModel.draw();
            modelViewMatrix = this.stack.pop();


            this.stack.push(mat4.clone(modelViewMatrix));
                //var tv = vec3.create();
                var s = vec3.create();
                vec3.set(tv, 6, 8.5, -6.5); 
                mat4.translate(modelViewMatrix,modelViewMatrix,tv);

                vec3.set(s, 0.01, 0.01, 0.01); 
                mat4.scale(modelViewMatrix,modelViewMatrix,s);
                vec3.set(tv, -this.statue.object.center[0], -this.statue.object.center[1]+8,-this.statue.object.center[2]+8); 
                mat4.translate(modelViewMatrix,modelViewMatrix,tv);
                //mat4.rotateX(modelViewMatrix,modelViewMatrix, -30.0 * Math.PI / 180);
                //mat4.rotateY(modelViewMatrix,modelViewMatrix, -10.0 * Math.PI / 180);
                //mat4.rotateZ(modelViewMatrix,modelViewMatrix, -12.0 * Math.PI / 180);
                this.updateModelViewMatrix(this.statue.program,modelViewMatrix,"uModelViewMatrix");
                this.statueModel.draw();
            modelViewMatrix = this.stack.pop();



            this.stack.push(mat4.clone(modelViewMatrix));
                var tv = vec3.create();
                var s = vec3.create();
                vec3.set(tv, 40, -3.0, 20); 
                mat4.translate(modelViewMatrix,modelViewMatrix,tv);

                vec3.set(s, 0.05, 0.05, 0.05); 
                mat4.scale(modelViewMatrix,modelViewMatrix,s);
                //vec3.set(tv, -this.statue.object.center[0], -this.statue.object.center[1],-this.statue.object.center[2]); 
                //mat4.translate(modelViewMatrix,modelViewMatrix,tv);
                mat4.rotateX(modelViewMatrix,modelViewMatrix, -90.0 * Math.PI / 180);
                //mat4.rotateY(modelViewMatrix,modelViewMatrix, -10.0 * Math.PI / 180);
                //mat4.rotateZ(modelViewMatrix,modelViewMatrix, -12.0 * Math.PI / 180);
                this.updateModelViewMatrix(this.tree.program,modelViewMatrix,"uModelViewMatrix");
                this.treeModel.draw();
            modelViewMatrix = this.stack.pop();
              //this.gl.enable(this.gl.DEPTH_TEST);
            

              // this.bezierModel[1].draw();
              // this.bezierModel[2].draw();
              

            //  this.bsplineModel[1].draw();
            //  this.bsplineModel[2].draw();
              
            //this.triangleModel.draw();
        }


        draw() {
           
            
            this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
           
            var tv = vec3.create();
            vec3.set(tv, this.translationVector[0], this.translationVector[1], this.translationVector[2]);
        
            //this.rotationVector[1]+=1;
            mat4.fromTranslation(this.modelViewMatrix,tv);
            mat4.rotateX(this.modelViewMatrix,this.modelViewMatrix,this.rotationVector[0] * Math.PI / 180);
            mat4.rotateY(this.modelViewMatrix,this.modelViewMatrix,this.rotationVector[1] * Math.PI / 180);
            mat4.rotateZ(this.modelViewMatrix,this.modelViewMatrix,this.rotationVector[2] * Math.PI / 180);

            this.updateModelViewMatrix(this.program,this.modelViewMatrix,"uModelViewMatrix");   
            this.updateModelViewMatrix(this.programLines,this.modelViewMatrix,"uModelViewMatrix");   
            this.updateModelViewMatrix(this.programNoise,this.modelViewMatrix,"uModelViewMatrix");  
            this.updateModelViewMatrix(this.programMesh,this.modelViewMatrix,"uModelViewMatrix");  
            

            mat4.identity(this.normalMatrix);
            mat4.invert(this.normalMatrix,this.modelViewMatrix);
            mat4.transpose(this.normalMatrix,this.normalMatrix);

            this.updateNormalMatrix(this.program,this.normalMatrix,"uNormalMatrix");            
            this.updateNormalMatrix(this.programLines,this.normalMatrix,"uNormalMatrix");    
            this.updateNormalMatrix(this.programNoise,this.normalMatrix,"uNormalMatrix");           
            this.updateNormalMatrix(this.programMesh,this.normalMatrix,"uNormalMatrix");           


            mat4.identity(this.projectionMatrix);  
            mat4.perspective(this.projectionMatrix, this.fov*(Math.PI/180), this.gl.canvas.width / this.gl.canvas.height, 0.1, 1000);

            this.updateProjectionMatrix(this.program,this.projectionMatrix,"uProjectionMatrix");
            this.updateProjectionMatrix(this.programLines,this.projectionMatrix,"uProjectionMatrix");
            this.updateProjectionMatrix(this.programNoise,this.projectionMatrix,"uProjectionMatrix");
            this.updateProjectionMatrix(this.programMesh,this.projectionMatrix,"uProjectionMatrix");
    
            this.drawScene(this.modelViewMatrix);

        } 

        initControls(){
        
            var obj = this;

            //var axis = ["x","y","z"];

            // A wrapper around dat.GUI interface for a simpler API
            // for the purpose of this book
            utils.configureControls({
                
                /*
                'Rendering Mode': {
                value: renderingMode,
                options: [
                    'TRIANGLES',
                    'LINES',
                    'POINTS',
                    'LINE_LOOP',
                    'LINE_STRIP',
                    'TRIANGLE_STRIP',
                    'TRIANGLE_FAN'
                ],
                onChange: v => {renderingMode = v;render();}
                },*/

                
                // reduce receives a function and the initial value (below the initial value is {})
                // result is the initial value or the return of the previous call to the function
                // Spread all values from the reduce onto the controls
                ...['Translate X', 'Translate Y', 'Translate Z'].reduce((result, name, i) => {
                result[name] = {
                    value: obj.translationVector[i],
                    min: -100, 
                    max: 100, 
                    step: 0.000001,
                    onChange(v, state){
                    obj.translationVector[i] = v;
                    obj.draw(); 
                    }
                };
                return result;
                }, {}),


                ...['Rotate X', 'Rotate Y', 'Rotate Z'].reduce((result, name, i) => {
                result[name] = {
                    value: obj.rotationVector[i],
                    min: -180, max: 180, step: 0.000001,
                    onChange(v, state) {
                    obj.rotationVector = [
                        state['Rotate X'],
                        state['Rotate Y'],
                        state['Rotate Z']
                    ];
                    obj.draw();  

                    }
                };
                return result;
                }, {}),

                
                'fov':{
                value: obj.fov,
                min : 0.0,
                max : 120,
                step: 0.001,
                onChange(v,state){
                    obj.fov = v;
                    obj.draw();
                }
            }
        })
    }



        init() {
            this.gl.clearColor(0.6, 0.7, 1.0, 1.0);
            this.gl.enable(this.gl.DEPTH_TEST);
            super.init();
        }
   
  }

  </script>
</head>

<body>

  <canvas id="webgl-canvas" width="800" height="800">
    Your browser does not support the HTML5 canvas element.
  </canvas>

  <script type="text/javascript">
      let myWebGLMainAPP = new MyWebGLMainAPP();
      window.onload = myWebGLMainAPP.init();
  </script>

</body>

</html>
