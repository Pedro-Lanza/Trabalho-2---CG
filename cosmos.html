<html>
<head>
  <title>Rendering primitives</title>
  <!--<link rel="shortcut icon" type="image/png" href="../common/images/favicon.png" />-->

  <!-- libraries -->
  <!--<link rel="stylesheet" href="../common/lib/normalize.css">-->
  <!--<script type="text/javascript" src="../common/lib/dat.gui.js"></script>-->

  <!-- modules -->
  <!--<script type="text/javascript" src="../common/js/utils.js"></script>-->

  <!-- vertex shader -->

  <link rel="stylesheet" href="./lib/normalize.css">
  <script type="text/javascript" src="./lib/dat.gui.js"></script>
  <script type="text/javascript" src="./js/utils.js"></script>
  <script type="text/javascript" src="./lib/gl-matrix.js"></script>
  <script type="text/javascript" src="./objects.js"></script>
  <script type="text/javascript" src="./simpleGLStack.js"></script>
  <script type="text/javascript" src="./geometry.js"></script>
  <script type="text/javascript" src="./webGLApp.js"></script>
  <script type="text/javascript" src="./webGLModel.js"></script>
  <script type="text/javascript" src="./shapes.js"></script>
  <script type="text/javascript" src="./shapesWebGL.js"></script>
  <script type="text/javascript" src="./squareDiamond.js"></script>
<!--Vertex Shader-->
   
<script id="vertex-shader" type="x-shader/x-vertex">
    
  </script>
  


  <!-- fragment shader -->
  <script id="fragment-shader" type="x-shader/x-fragment">
    
  </script>


  <script type="text/javascript">
  
    class MyWebGLMainAPP extends WebGLMainApp{
    
        constructor(){
            super();
            this.program = null;
            this.fov = 60;
            this.rotationVector = [0.0,0.0,0.0];
            this.lightPos = [0.0,0.0,0.0];
            this.translationVector = [0.0,0.0,-30.0];
            this.planets = [];
            this.stack = new SimpleGLStack();
        }

        createTransformMatrices(){
        
            this.modelViewMatrix = mat4.create();
            this.modelViewMatrixClean = mat4.create();
            this.projectionMatrix = mat4.create();
            this.normalMatrix = mat4.create();
            this.time = 0.0;

            var tv = vec3.create();

            vec3.set(tv, this.translationVector[0], this.translationVector[1], this.translationVector[2]);

            mat4.fromTranslation(this.modelViewMatrix,tv);
            mat4.rotateX(this.modelViewMatrix,this.modelViewMatrix,this.rotationVector[0] * Math.PI / 180);
            mat4.rotateY(this.modelViewMatrix,this.modelViewMatrix,this.rotationVector[1] * Math.PI / 180);
            mat4.rotateZ(this.modelViewMatrix,this.modelViewMatrix,this.rotationVector[2] * Math.PI / 180);

            mat4.fromTranslation(this.modelViewMatrixClean,tv);
            mat4.rotateX(this.modelViewMatrixClean,this.modelViewMatrixClean,this.rotationVector[0] * Math.PI / 180);
            mat4.rotateY(this.modelViewMatrixClean,this.modelViewMatrixClean,this.rotationVector[1] * Math.PI / 180);
            mat4.rotateZ(this.modelViewMatrixClean,this.modelViewMatrixClean,this.rotationVector[2] * Math.PI / 180);
            
            mat4.identity(this.normalMatrix);
            mat4.invert(this.normalMatrix,this.modelViewMatrix);
            mat4.transpose(this.normalMatrix,this.normalMatrix);

            //Cria a matriz de projeção com angulo de abertura de 45 graus, near plane = 0.1 e far_plane = 1000
            mat4.identity(this.projectionMatrix);  
            mat4.perspective(this.projectionMatrix, this.fov*(Math.PI/180), this.gl.canvas.width / this.gl.canvas.height, 0.1, 1000);

        }

        

        async createModels(){

            this.sun = new Sun(this, "sun-texture.png");

            this.earth = new Planet(this, "mars-texture.png", 1.0, 10.0, 1.75);
            this.earth2 = new Planet(this, "mars-texture.png", 1.0, 15.0, -5.0);
            this.earth3 = new Planet(this, "mars-texture.png", 1.0, 6.0, 0.55);
            this.earth4 = new Planet(this, "mars-texture.png", 1.0, 30.0, 2.0);
            this.planets.push(this.earth, this.earth2, this.earth3, this.earth4);

        }

        async create(){
        
            // Carrega um program       
            //this.program = this.createProgram("vertex-shader","fragment-shader");
            this.program = await this.loadProgram("vertexShader.sh","fragmentShader.sh");
            if (!this.program) {
                console.error("Failed to create shader program");
                return;
            }
            console.log("Shader program created successfully");


            this.program = await this.loadProgram("vertexShader.sh","fragmentShader.sh");
            this.programSpecific = await this.loadProgram("sunVertexShader.sh", "fragmentShader.sh"); // Load the new shader program
            this.programMesh = await this.loadProgram("vertexShaderMesh.sh","fragmentShader.sh");
            this.programLines = await this.loadProgram("vertexShaderLines.sh","fragmentShaderLines.sh");
            this.programNoise = await this.loadProgram("vertexShaderNoise.sh","fragmentShader.sh");
            
            this.gl.useProgram(this.program);

            //Define as variáveis attribute e uniform dos shaders
            this.attribShaderVariables = {"aVertexPosition":"aVertexPosition",
                                          "aVertexColor":"aVertexColor",
                                          "aVertexNormal":"aVertexNormal",
                                          "aVertexTextureCoord":"aTextureCoordinate"};

            this.uniformShaderVariables = ["uVertexPointSize","uModelViewMatrix", "uModelViewMatrixClean","uNormalMatrix","uProjectionMatrix",
                                           "uLightPos","uEyePos","uTextureActive","uSampler", "uTime",
                                            "uRadius", "uSpeed"];
            
            //Define as variáveis attribute e uniform dos shaders para linhas
            this.attribShaderLinesVariables = {"aVertexPosition":"aVertexPosition",
                                              "aVertexColor":"aVertexColor",
                                              "aVertexTextureCoord":"aTextureCoordinate"};

            this.uniformShaderLinesVariables = ["uVertexPointSize","uModelViewMatrix", "uModelViewMatrixClean","uProjectionMatrix","uTextureActive","uSampler"];
            

            //Define as variáveis attribute e uniform dos shaders de malhas
            this.attribShaderMeshVariables = {"aVertexPosition":"aVertexPosition",
                                              "aVertexNormal":"aVertexNormal",
                                              "aVertexTextureCoord":"aTextureCoordinate"};

            this.uniformShaderMeshVariables = ["uVertexPointSize","uModelViewMatrix", "uModelViewMatrixClean","uNormalMatrix","uProjectionMatrix",
                                               "uLightPos","uEyePos",
                                               "uMatAmbient",
                                               "uKa",
                                               "uMatDiffuse",
                                               "uKd",
                                               "uMatSpecular",
                                               "uKs",
                                               "uNs",
                                               "uD",
                                               "uTextureActive","uSampler"];
            


            //Obtem a localização das variáveis no shader
            this.setProgramAttribShaderVariablesLocation(this.program,this.attribShaderVariables);
            this.setProgramUniformShaderVariablesLocation(this.program,this.uniformShaderVariables);

            this.setProgramAttribShaderVariablesLocation(this.programNoise,this.attribShaderVariables);
            this.setProgramUniformShaderVariablesLocation(this.programNoise,this.uniformShaderVariables);

            this.setProgramAttribShaderVariablesLocation(this.programLines,this.attribShaderLinesVariables);
            this.setProgramUniformShaderVariablesLocation(this.programLines,this.uniformShaderLinesVariables);
            
            this.setProgramAttribShaderVariablesLocation(this.programMesh,this.attribShaderMeshVariables);
            this.setProgramUniformShaderVariablesLocation(this.programMesh,this.uniformShaderMeshVariables);
            

            this.createTransformMatrices();
            
            await this.createModels();
            await this.createModels();


            var uniformShaderVariablesValues = {"uVertexPointSize":["1f",16.0],
                                                "uModelViewMatrix":["mat4",false,this.modelViewMatrix],
                                                "uModelViewMatrixClean":["mat4", false, this.modelViewMatrixClean],
                                                "uNormalMatrix":["mat4",false,this.normalMatrix],
                                                "uProjectionMatrix":["mat4",false,this.projectionMatrix],
                                                "uLightPos":["3f",this.lightPos[0],this.lightPos[1],this.lightPos[2]],
                                                "uEyePos":["3f",-this.translationVector[0],-this.translationVector[1],-this.translationVector[2]],
                                                "uTextureActive":["1i",1],
                                                "uSampler":["1i",0],
                                                "uTime": ["1f", this.time],
                                                "uRadius": ["1f", 0.0], // Example radius
                                                "uSpeed": ["1f", 1.0]    // Example speed
                                                };

            
            var uniformShaderLinesVariablesValues = {"uVertexPointSize":["1f",16.0],
                                                "uModelViewMatrix":["mat4",false,this.modelViewMatrix],
                                                "uModelViewMatrixClean":["mat4", false, this.modelViewMatrixClean],
                                                "uProjectionMatrix":["mat4",false,this.projectionMatrix],
                                                "uTextureActive":["1i",0],
                                                "uSampler":["1i",0]};

            var uniformShaderMeshVariablesValues = {"uVertexPointSize":["1f",16.0],
                                                "uModelViewMatrix":["mat4",false,this.modelViewMatrix],
                                                "uModelViewMatrixClean":["mat4", false, this.modelViewMatrixClean],
                                                "uNormalMatrix":["mat4",false,this.normalMatrix],
                                                "uProjectionMatrix":["mat4",false,this.projectionMatrix],
                                                "uLightPos":["3f",this.lightPos[0],this.lightPos[1],this.lightPos[2]],
                                                "uEyePos":["3f",-this.translationVector[0],-this.translationVector[1],-this.translationVector[2]],
                                                "uMatAmbient":["4fv",[1.0,1.0,1.0,1.0]],
                                                "uKa":["3fv",[0.5,0.5,0.5]],
                                                "uMatDiffuse":["4fv",[1.0,1.0,1.0,1.0]],
                                                "uKd":["3fv",[0.5,0.5,0.5]],
                                                "uMatSpecular":["4fv",[1.0,1.0,1.0,1.0]],
                                                "uKs":["3fv",[0.5,0.5,0.5]],
                                                "uNs":["1f",0.5],
                                                "uD":["1f",1.0],
                                                "uTextureActive":["1i",1],
                                                "uSampler":["1i",0]};  

            

            this.setProgramUniformShaderVariablesValues(this.program,uniformShaderVariablesValues);
            this.setProgramUniformShaderVariablesValues(this.programSpecific, uniformShaderVariablesValues); // Set uniform values for the new program
            this.setProgramUniformShaderVariablesValues(this.programNoise,uniformShaderVariablesValues);
            this.setProgramUniformShaderVariablesValues(this.programLines,uniformShaderLinesVariablesValues);
            this.setProgramUniformShaderVariablesValues(this.programMesh,uniformShaderMeshVariablesValues);

 
        }


        drawScene(modelViewMatrix){

            this.gl.useProgram(this.programSpecific);
            this.stack.push(mat4.clone(modelViewMatrix));
                this.updateModelViewMatrix(this.sun.program, modelViewMatrix, "uModelViewMatrix");
                this.updateUniformValue(this.program, "uRadius", ["1f", this.sun.tRadius]);
                 this.updateUniformValue(this.program, "uSpeed", ["1f", this.sun.tSpeed]);
                this.sun.draw(modelViewMatrix);
            modelViewMatrix = this.stack.pop();

            this.gl.useProgram(this.program);
            for (var i = 0; i < this.planets.length; i++){
              this.stack.push(mat4.clone(modelViewMatrix));
                mat4.translate(modelViewMatrix, modelViewMatrix, this.planets[i].pos);
                this.updateModelViewMatrix(this.planets[i].program, modelViewMatrix, "uModelViewMatrix");
                this.updateUniformValue(this.program, "uRadius", ["1f", this.planets[i].tRadius]);
                this.updateUniformValue(this.program, "uSpeed", ["1f", this.planets[i].tSpeed]);
                this.planets[i].draw(modelViewMatrix);
              modelViewMatrix = this.stack.pop();
            }
        }


        draw() {
            this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
           
            this.gl.useProgram(this.program);
            if (!this.program.attribShaderVariables) {
                console.error("AttribShaderVariables not set for the program");
                return;
            }
            if (!this.program.uniformShaderVariables) {
                console.error("UniformShaderVariables not set for the program");
                return;
            }
            console.log("AAAAAAAAAAAAAAAAAA");
            console.log("Using program with attribShaderVariables: ", this.program.attribShaderVariables);
            console.log("Using program with attribShaderVariables: ", this.program.attribShaderVariables);
            console.log("Using program with attribShaderVariables: ", this.program.attribShaderVariables);
            console.log("Using program with attribShaderVariables: ", this.program.attribShaderVariables);
            console.log("Using program with attribShaderVariables: ", this.program.attribShaderVariables);
            console.log("Using program with attribShaderVariables: ", this.program.attribShaderVariables);
            console.log("Using program with attribShaderVariables: ", this.program.attribShaderVariables);
            console.log("BBBBBBBBBBBBBBBBBBBBBBBBBBB");


            var tv = vec3.create();
            vec3.set(tv, this.translationVector[0], this.translationVector[1], this.translationVector[2]);
        
            
            // this.rotationVector[1]+=1;
            mat4.fromTranslation(this.modelViewMatrix,tv);
            mat4.rotateX(this.modelViewMatrix,this.modelViewMatrix,this.rotationVector[0] * Math.PI / 180);
            mat4.rotateY(this.modelViewMatrix,this.modelViewMatrix,this.rotationVector[1] * Math.PI / 180);
            mat4.rotateZ(this.modelViewMatrix,this.modelViewMatrix,this.rotationVector[2] * Math.PI / 180);

            this.updateModelViewMatrix(this.program,this.modelViewMatrix,"uModelViewMatrix");   
            this.updateModelViewMatrix(this.programLines,this.modelViewMatrix,"uModelViewMatrix");   
            this.updateModelViewMatrix(this.programNoise,this.modelViewMatrix,"uModelViewMatrix");  
            this.updateModelViewMatrix(this.programMesh,this.modelViewMatrix,"uModelViewMatrix");
            
            mat4.fromTranslation(this.modelViewMatrixClean,tv);
            mat4.rotateX(this.modelViewMatrixClean,this.modelViewMatrixClean,this.rotationVector[0] * Math.PI / 180);
            mat4.rotateY(this.modelViewMatrixClean,this.modelViewMatrixClean,this.rotationVector[1] * Math.PI / 180);
            mat4.rotateZ(this.modelViewMatrixClean,this.modelViewMatrixClean,this.rotationVector[2] * Math.PI / 180);

            this.updateModelViewMatrix(this.program,this.modelViewMatrix,"uModelViewMatrixClean");   
            this.updateModelViewMatrix(this.programLines,this.modelViewMatrix,"uModelViewMatrixClean");   
            this.updateModelViewMatrix(this.programNoise,this.modelViewMatrix,"uModelViewMatrixClean");  
            this.updateModelViewMatrix(this.programMesh,this.modelViewMatrix,"uModelViewMatrixClean");



            mat4.identity(this.normalMatrix);
            mat4.invert(this.normalMatrix,this.modelViewMatrix);
            mat4.transpose(this.normalMatrix,this.normalMatrix);

            this.updateNormalMatrix(this.program,this.normalMatrix,"uNormalMatrix");            
            this.updateNormalMatrix(this.programLines,this.normalMatrix,"uNormalMatrix");    
            this.updateNormalMatrix(this.programNoise,this.normalMatrix,"uNormalMatrix");           
            this.updateNormalMatrix(this.programMesh,this.normalMatrix,"uNormalMatrix");           


            mat4.identity(this.projectionMatrix);  
            mat4.perspective(this.projectionMatrix, this.fov*(Math.PI/180), this.gl.canvas.width / this.gl.canvas.height, 0.1, 1000);

            this.updateProjectionMatrix(this.program,this.projectionMatrix,"uProjectionMatrix");
            this.updateProjectionMatrix(this.programLines,this.projectionMatrix,"uProjectionMatrix");
            this.updateProjectionMatrix(this.programNoise,this.projectionMatrix,"uProjectionMatrix");
            this.updateProjectionMatrix(this.programMesh,this.projectionMatrix,"uProjectionMatrix");
    
            this.time += 0.01;
            this.updateUniformTime(this.program, this.time, "uTime");

            this.drawScene(this.modelViewMatrix);

            // requestAnimationFrame(this.draw.bind(this));
        } 

        initControls(){
        
            var obj = this;

            //var axis = ["x","y","z"];

            // A wrapper around dat.GUI interface for a simpler API
            // for the purpose of this book
            utils.configureControls({
                
                /*
                'Rendering Mode': {
                value: renderingMode,
                options: [
                    'TRIANGLES',
                    'LINES',
                    'POINTS',
                    'LINE_LOOP',
                    'LINE_STRIP',
                    'TRIANGLE_STRIP',
                    'TRIANGLE_FAN'
                ],
                onChange: v => {renderingMode = v;render();}
                },*/

                
                // reduce receives a function and the initial value (below the initial value is {})
                // result is the initial value or the return of the previous call to the function
                // Spread all values from the reduce onto the controls
                ...['Translate X', 'Translate Y', 'Translate Z'].reduce((result, name, i) => {
                result[name] = {
                    value: obj.translationVector[i],
                    min: -100, 
                    max: 100, 
                    step: 0.000001,
                    onChange(v, state){
                    obj.translationVector[i] = v;
                    obj.draw(); 
                    }
                };
                return result;
                }, {}),


                ...['Rotate X', 'Rotate Y', 'Rotate Z'].reduce((result, name, i) => {
                result[name] = {
                    value: obj.rotationVector[i],
                    min: -180, max: 180, step: 0.000001,
                    onChange(v, state) {
                    obj.rotationVector = [
                        state['Rotate X'],
                        state['Rotate Y'],
                        state['Rotate Z']
                    ];
                    obj.draw();  

                    }
                };
                return result;
                }, {}),

                
                'fov':{
                value: obj.fov,
                min : 0.0,
                max : 120,
                step: 0.001,
                onChange(v,state){
                    obj.fov = v;
                    obj.draw();
                }
            }
        })
    }



        init() {
            // this.gl.clearColor(0.6, 0.7, 1.0, 1.0);
            this.gl.enable(this.gl.DEPTH_TEST);
            super.init();
        }
   
  }

  </script>
</head>

<body>

  <canvas id="webgl-canvas" width="800" height="800" style="background-color: black;">
    Your browser does not support the HTML5 canvas element.
  </canvas>

  <script type="text/javascript">
      let myWebGLMainAPP = new MyWebGLMainAPP();
      window.onload = myWebGLMainAPP.init();
  </script>

</body>

</html>
